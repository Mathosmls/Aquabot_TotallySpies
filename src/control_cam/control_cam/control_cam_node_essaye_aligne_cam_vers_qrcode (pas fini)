#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import Float64
from geometry_msgs.msg import PoseArray
from nav_msgs.msg import Odometry
import cv2
from cv_bridge import CvBridge
import math


class ControlCamNode(Node):

    def __init__(self):
        super().__init__('control_cam_node')
        self.get_logger().info('Control_cam_node initialized successfully!')

        # Créer un éditeur pour contrôler l'angle de la caméra
        self.publisher_ = self.create_publisher(Float64, '/aquabot/thrusters/main_camera_sensor/pos', 10)

        # Créer un souscripteur pour recevoir les images
        self.subscriber = self.create_subscription(Image, '/aquabot/sensors/cameras/main_camera_sensor/image_raw', self.image_callback, 10)
        
        # Souscription au topic /odometry/filtered/map
        self.subscription = self.create_subscription(Odometry, '/odometry/filtered/map', self.pos_callback, 10)

        # Outil pour convertir entre les images ROS et OpenCV
        self.br = CvBridge()

        # Initialiser l'angle courant de la caméra
        self.current_angle = 0.0

        # Initialiser l'angle total de la caméra que l'on a modifié
        self.total_modified_angle = 0.0

        # Initialiser les coordonnées du QR code cible
        self.qr_position = None  # (x, y) in pixel coordinates of the image

        # Gain de régulation proportionnelle
        self.kp = 0.01  # à ajuster selon la réactivité souhaitée

    def set_camera_angle(self, target_angle):
        """Calcule et publie l'angle optimal pour orienter la caméra"""
        delta_angle = target_angle - self.current_angle

        # Ajuster pour minimiser la rotation (angle parcouru max : 180 degrés)
        if delta_angle > math.pi:
            delta_angle -= 2 * math.pi
        elif delta_angle < -math.pi:
            delta_angle += 2 * math.pi

        # Régulation proportionnelle pour ajuster l'angle
        adjustment = self.kp * delta_angle
        self.current_angle += adjustment
        self.current_angle = (self.current_angle + 2 * math.pi) % (2 * math.pi)  # Garder l'angle entre 0 et 2pi
        
        self.total_modified_angle += adjustment

        # Publier l'angle ajusté
        msg = Float64()
        msg.data = self.current_angle
        self.publisher_.publish(msg)
        self.get_logger().info(f'Camera angle adjusted to: {self.current_angle:.2f} radians')

    def pos_callback(self, msg):
        """Callback pour recevoir la position de la caméra à partir du topic /odometry/filtered/map"""
        self.camera_position = [msg.pose.pose.position.x, msg.pose.pose.position.y]

    def image_callback(self, msg):
        """Callback pour traiter les images de la caméra"""
        # Convertir le message ROS Image en image OpenCV
        current_frame = self.br.imgmsg_to_cv2(msg)


        # Convertir l'image en niveaux de gris (facilite la détection de QR code)
        gray_frame = cv2.cvtColor(current_frame, cv2.COLOR_RGB2BGR)

        # Utiliser le détecteur QRCodeDetector d'OpenCV
        qr_detector = cv2.QRCodeDetector()
        data, points, _ = qr_detector.detectAndDecode(gray_frame)        

        if points is not None:
             # QR Code détecté
            self.get_logger().info(f"QR Code detected: {data}")
            
            # Calculer le centre du QR code en prenant la moyenne des 4 coins
            # points[0] contient les 4 coins du QR code, qui sont des coordonnées en flottant 
            x_center = int(sum([point[0] for point in points[0]]) / 4) 
            y_center = int(sum([point[1] for point in points[0]]) / 4)
            
            self.qr_position = (x_center, y_center)

            # Dessiner le contour et le centre du QR code pour visualisation
            for i in range(len(points[0])):
                pt1 = tuple(map(int, points[0][i]))  # Conversion explicite en tuple d'entiers
                pt2 = tuple(map(int, points[0][(i + 1) % len(points[0])]))  # Conversion explicite en tuple d'entiers
                cv2.line(current_frame, pt1, pt2, (0, 255, 0), 2)

            # Dessiner un cercle au centre du QR code
            cv2.circle(current_frame, self.qr_position, 5, (0, 0, 255), -1)

            # Calculer l'angle cible si la position du QR code est au centre de l'image
            image_width = current_frame.shape[1]
            image_center_x = image_width // 2

            # Calcul de l'angle cible basé sur la différence entre le centre de l'image et la position du QR code
            offset_x = self.qr_position[0] - image_center_x
            target_angle = math.atan2(offset_x, image_width)  # Utilise la largeur pour ajuster la sensibilité

            # Ajuster l'angle de la caméra
            self.set_camera_angle(target_angle)

        # Afficher l'image avec les annotations
        cv2.imshow("Image", current_frame)
        cv2.waitKey(1)


def main(args=None):
    rclpy.init(args=args)

    # Initialisation du nœud ControlCamNode
    control_cam_node = ControlCamNode()

    # Boucle d'exécution du nœud
    rclpy.spin(control_cam_node)

    # Détruire le nœud et éteindre ROS2
    control_cam_node.destroy_node()
    rclpy.shutdown()

    #print("Total modified angle:", control_cam_node.total_modified_angle)


if __name__ == '__main__':
    main()
