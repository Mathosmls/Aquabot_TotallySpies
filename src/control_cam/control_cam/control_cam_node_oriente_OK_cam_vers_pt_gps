#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import Float64
from geometry_msgs.msg import PoseArray
from nav_msgs.msg import Odometry
import cv2
from cv_bridge import CvBridge
import math


class ControlCamNode(Node):

    def __init__(self):
        super().__init__('control_cam_node')
        self.get_logger().info('Control_cam_node initialized successfully!')

        # Créer un éditeur pour contrôler l'angle de la caméra
        self.publisher_ = self.create_publisher(Float64, '/aquabot/thrusters/main_camera_sensor/pos', 10)

        # Créer un souscripteur pour recevoir les images
        self.subscriber = self.create_subscription(Image, '/aquabot/sensors/cameras/main_camera_sensor/image_raw', self.image_callback, 10)
        
        # Souscription au topic /odometry/filtered/map
        self.subscription = self.create_subscription(Odometry, '/odometry/filtered/map', self.pos_callback, 10)

        # Outil pour convertir entre les images ROS et OpenCV
        self.br = CvBridge()

        # Initialiser l'angle courant de la caméra
        self.current_angle = 0.0

        # Initialiser l'angle total de la caméra que l'on a modifié
        self.total_modified_angle = 0.0

        # Initialiser les coordonnées du point cible (par défaut à None)
        self.target_position = [10, 0]
        self.camera_position = [0, 0]

        # Gain de régulation proportionnelle
        self.kp = 0.1  # d'après les tests, 0.1 est un bon choix 

    def set_camera_angle(self, target_angle):
        """Calcule et publie l'angle optimal pour orienter la caméra"""

        # Calculer la différence d'angle
        delta_angle = target_angle - self.current_angle

        # Ajuster pour minimiser la rotation (angle parcouru max : 180 degrés)
        if delta_angle > math.pi:
            delta_angle -= 2 * math.pi
        elif delta_angle < -math.pi:
            delta_angle += 2 * math.pi

        # Régulation proportionnelle pour ajuster l'angle
        adjustment = self.kp * delta_angle
        self.current_angle += adjustment
        self.current_angle = (self.current_angle + 2 * math.pi) % (2 * math.pi)  # Garder l'angle entre 0 et 2π
        
        self.total_modified_angle += adjustment
        print("angle total",self.total_modified_angle)

        # Publier l'angle ajusté
        msg = Float64()
        msg.data = self.current_angle
        self.publisher_.publish(msg)
        self.get_logger().info(f'Camera angle adjusted to: {self.current_angle:.2f} radians')

    def pos_callback(self, msg):
        """Callback pour recevoir la position de la caméra à partir du topic /odometry/filtered/map"""
        # Extraire la position de la caméra depuis le message Odometry
        self.camera_position[0] = msg.pose.pose.position.x
        self.camera_position[1] = msg.pose.pose.position.y
        #self.get_logger().info(f"Updated camera position: x={self.camera_position[0]}, y={self.camera_position[1]}")

    def image_callback(self, msg):
        """Callback pour traiter les images de la caméra"""
        # Convertir le message ROS Image en image OpenCV
        current_frame = self.br.imgmsg_to_cv2(msg)

        # Convertir l'image de BGR à RGB
        current_frame = cv2.cvtColor(current_frame, cv2.COLOR_BGR2RGB)
    
        # Afficher l'image
        cv2.imshow("Image", current_frame)
        cv2.waitKey(1)

        # Si la position cible et celle de la caméra sont disponibles, calculer l'angle
        if self.target_position and self.camera_position:
            target_x, target_y = self.target_position
            cam_x, cam_y = self.camera_position

            # Calcul de l'angle cible en radians
            target_angle = math.atan2(target_y - cam_y, target_x - cam_x)

            # Ajuster l'angle de la caméra pour qu'il corresponde à l'angle cible
            self.set_camera_angle(target_angle)


        else:
            # Si aucun QR code n'est détecté, on ne touche pas à l'angle de la caméra
            # Enlever les commentaires si besoin dans l'évolution du code        
            #target_angle = 0.0
            #self.set_camera_angle(target_angle)
            pass


def main(args=None):
    rclpy.init(args=args)

    # Initialisation du nœud ControlCamNode
    control_cam_node = ControlCamNode()

    # Boucle d'exécution du nœud
    rclpy.spin(control_cam_node)

    # Détruire le nœud et éteindre ROS2
    control_cam_node.destroy_node()
    rclpy.shutdown()

    


if __name__ == '__main__':
    main()
